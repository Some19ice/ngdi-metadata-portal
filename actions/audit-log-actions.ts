"use server"

import { db } from "@/db/db"
import {
  auditLogsTable,
  InsertAuditLog,
  SelectAuditLog,
  auditLogActionCategoryEnum,
  auditLogTargetEntityTypeEnum
} from "@/db/schema/audit-logs-schema"
import { ActionState } from "@/types"
import { auth } from "@clerk/nextjs/server"
import { eq, desc, and, or, ilike, sql, count, gte, lte } from "drizzle-orm"
import { checkUserRole } from "@/lib/rbac"

// Type for the input, omitting auto-generated fields like id and timestamp
// We'll take userId explicitly
export type CreateAuditLogInput = Omit<
  InsertAuditLog,
  "id" | "timestamp" | "userId"
>

export async function createAuditLogAction(
  logData: CreateAuditLogInput
): Promise<ActionState<SelectAuditLog>> {
  const { userId: currentUserId } = await auth()

  if (!currentUserId) {
    // This should ideally not happen if called from an authenticated context,
    // but as a safeguard for the log itself.
    console.error("Attempted to create audit log without a user session.")
    return {
      isSuccess: false,
      message: "Audit log creation failed: User not authenticated."
    }
  }

  const completeLogData: InsertAuditLog = {
    ...logData,
    userId: currentUserId
    // id and timestamp will be auto-generated by the database
  }

  try {
    const [newLog] = await db
      .insert(auditLogsTable)
      .values(completeLogData)
      .returning()

    return {
      isSuccess: true,
      message: "Audit log created successfully.",
      data: newLog
    }
  } catch (error) {
    console.error("Error creating audit log:", error)
    // In a real scenario, you might want to send this to a dedicated logging service
    // and not fail the primary user action if audit logging fails.
    // However, for now, we'll report it as a failure of the log action itself.
    return {
      isSuccess: false,
      message: "Failed to create audit log entry."
    }
  }
}

// --- Get Audit Logs Action ---
export interface GetAuditLogsParams {
  query?: string // Search term for userId or targetEntityId
  actionCategory?: (typeof auditLogActionCategoryEnum.enumValues)[number]
  actionType?: string // Specific action type like 'UserLoggedIn', 'OrganizationCreated'
  userId?: string
  targetEntityType?: (typeof auditLogTargetEntityTypeEnum.enumValues)[number]
  targetEntityId?: string
  dateFrom?: string // ISO Date string
  dateTo?: string // ISO Date string
  page?: number
  pageSize?: number
}

export interface PaginatedAuditLogs {
  logs: SelectAuditLog[]
  totalLogs: number
  totalPages: number
  currentPage: number
  pageSize: number
}

export async function getAuditLogsAction(
  params: GetAuditLogsParams
): Promise<ActionState<PaginatedAuditLogs>> {
  const { userId: currentUserId } = await auth()
  if (!currentUserId) {
    return { isSuccess: false, message: "User not authenticated." }
  }

  // Ensure only System Administrators can view audit logs
  const isAdmin = await checkUserRole(currentUserId, "System Administrator")
  if (!isAdmin) {
    return {
      isSuccess: false,
      message: "Unauthorized: You do not have permission to view audit logs."
    }
  }

  try {
    const conditions = []
    const pageNumber = params.page || 1
    const size = params.pageSize || 20
    const offset = (pageNumber - 1) * size

    if (params.query) {
      const q = `%${params.query}%` // For ilike, if needed for other fields
      conditions.push(
        or(
          eq(auditLogsTable.userId, params.query), // Exact match for IDs usually better
          eq(auditLogsTable.targetEntityId, params.query)
        )
      )
    }

    if (params.actionCategory) {
      conditions.push(eq(auditLogsTable.actionCategory, params.actionCategory))
    }
    if (params.actionType) {
      conditions.push(eq(auditLogsTable.actionType, params.actionType))
    }
    // If specific userId filter is provided, override the general query for userId
    if (params.userId) {
      conditions.push(eq(auditLogsTable.userId, params.userId))
    }
    if (params.targetEntityType) {
      conditions.push(
        eq(auditLogsTable.targetEntityType, params.targetEntityType)
      )
    }
    // If specific targetEntityId filter is provided, override the general query for targetEntityId
    if (params.targetEntityId) {
      conditions.push(eq(auditLogsTable.targetEntityId, params.targetEntityId))
    }

    if (params.dateFrom) {
      conditions.push(gte(auditLogsTable.timestamp, new Date(params.dateFrom)))
    }
    if (params.dateTo) {
      // Add 1 day to dateTo to make it inclusive of the whole day
      const dateToInclusive = new Date(params.dateTo)
      dateToInclusive.setDate(dateToInclusive.getDate() + 1)
      conditions.push(lte(auditLogsTable.timestamp, dateToInclusive))
    }

    const finalConditions =
      conditions.length > 0 ? and(...conditions) : undefined

    const logsQuery = db.query.auditLogs.findMany({
      where: finalConditions,
      orderBy: [desc(auditLogsTable.timestamp)],
      limit: size,
      offset: offset
    })

    const totalLogsQuery = db
      .select({ count: count(auditLogsTable.id) })
      .from(auditLogsTable)
      .where(finalConditions)

    const [logs, totalResult] = await Promise.all([logsQuery, totalLogsQuery])

    const totalLogs = totalResult[0]?.count || 0
    const totalPages = Math.ceil(totalLogs / size)

    return {
      isSuccess: true,
      message: "Audit logs retrieved successfully.",
      data: {
        logs,
        totalLogs,
        totalPages,
        currentPage: pageNumber,
        pageSize: size
      }
    }
  } catch (error) {
    console.error("Error fetching audit logs:", error)
    return {
      isSuccess: false,
      message: "An unexpected error occurred while fetching audit logs."
    }
  }
}
